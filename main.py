# -*- coding: utf-8 -*-

# Algorithmic Paradigm
# 【concurrency】
# philosopher
# 【parallelism】
# 【divide and conquer】
# binary search
# merge sort
# quick sort
# 【dynamic programming】
# knapsack
# 【greedy】


# 问题归类
# 【linear extension】
# a linear order (or total order) that is compatible with the partial order
# 即根据一个偏序得出一个与之并不矛盾的全序
# 此类问题有：拓扑排序；MRO

# 【从数的二进制表示，2^0+2^1+...+2^n=2^(n+1)-1】
# 二叉树中同时具有左右子树的节点个数一定等于该树叶子节点的个数减一
# 此类算法诸如：
# 1) 找到不小于一个数的2的幂，利用"位操作或"实现累加
# 2) 完全背包转换成0-1背包，利用"加法"实现累加
# 3) 后缀数组O(nlogn)的构造，利用"排序的稳定性"实现累加

# 【subsequence vs. substring】
# 需严格区分subsequence和substring这两个词
# 前者是指非连续的序列问题，后者则针对连续的字符串


# 技巧
# 【递归】
# 利用对于递归的调用与返回，形成了一次折返，极大地简化了数据结构的遍历
# 例如在以递归方式实现的红黑树中，可以将原本复杂的平衡算法拆分成两个部分
# 即在top-down和buttom-up阶段分别予以实现


# 关于红黑树的思考
# 根据红黑树的平衡算法得到的整棵二叉树不是完全平衡的
# 表现出的恰恰是一种"多样性"，虽局限于某个范围/限制内

# 分治 & 动态规划
# 1) 共性
# 将原问题分解成更小规模的子问题-->最后再对子问题的解进行统一处理，从而得到原问题的解
# 2) 区别
# 分治算法所分解出的子问题之间相互独立-->最终需要合并子问题的解，故有：原问题的复杂度=所有子问题的复杂度之和+合并的复杂度
# 动规算法所分解出的子问题之间存在重叠-->最终需要筛选子问题的解，故有：原问题的复杂度=所有子问题的复杂度之和+筛选的复杂度
# 3) 基于上述共性和区别得出两者的特征
# 对于分治而言，降低其时间复杂度的关键在于如何划分子问题使得合并的代价最小。
# 对于动规而言，降低其时间复杂度的关键在于如何尽可能地对子问题的解进行复用。
# 4) 两者体现的是两种解决问题的常用策略：
# division：将问题分解成几个阶段或步骤，将某个阶段的输出作为下一个阶段的输入(即累积的过程)，或最终合并所有子阶段的输出
# reduction，将问题降解为更小规模的子问题，通过归纳或递推的方式得到最终解
# 【华容道】总是先解决较小的矩形，如单行或列，再以同样的方式解决余下的矩形
# 【2048】要求得2048游戏中可获取的最大数，就可以先分析“在较小矩形下所能求得的最大数”，再归纳至“任意大小的矩形”的情况。
